<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[ActiveMQ的使用]]></title>
    <url>%2F2019%2F01%2F17%2FActiveMQ%E7%9A%84%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[Java环境下的使用 ActiveMQ集成spring ActiveMQ集成springboot ActiveMQ的引言1ActiveMQ是由Apache出品的，一款最流行的，能力强劲的消息中间件（MOM：Message Orient middleware）。并且是对消息通信规范JMS的一种具体实现 1.安装ActiveMQ1.搭建java环境2.安装ActiveMq121.解压activemq的tar -zxvf 2.修改映射文件 将主机名映射本机的ip /etc/hosts 3.测试访问web的控制界面 2.java操作ActiveMQ1.点对点(p2p)1.生产者1.相关依赖12345&lt;dependency&gt; &lt;groupId&gt;org.apache.activemq&lt;/groupId&gt; &lt;artifactId&gt;activemq-core&lt;/artifactId&gt; &lt;version&gt;5.7.0&lt;/version&gt;&lt;/dependency&gt; 2.开发步骤123456789101112131415161718192021222324252627 //tcp连接 String brokerURL = "tcp://192.168.106.135:61616"; @Test public void testProducter() throws JMSException &#123; //1.连接工厂 ConnectionFactory connectionFactory = new ActiveMQConnectionFactory(brokeURl); //2.创建连接 Connection connection = connectionFactory.createConnection(); connection.start(); //开启连接 //3.创建会话 //第一个参数 代表第二参数是否生效开启事务 参数二 自动发送回执 Session session = connection.createSession(true, Session.AUTO_ACKNOWLEDGE); //4.创建生产者 Destination destination = new ActiveMQQueue("javaQueue"); MessageProducer producer = session.createProducer(destination); //5.创建消息 session获取或者直接new ActiveMQTextMessage()等不同的实现类 TextMessage textMessage = session.createTextMessage(); textMessage.setText("hello rlk");// 6.使用生产者发送消息 producer.send(textMessage);// 7.提交 提交是必须的 session.commit();// 8.关闭 producer.close(); session.close(); connection.close();&#125; 2.消费者开发步骤123456789101112131415161718192021222324//1.创建工厂//2.创建连接//3.启动连接//4.创建会话//5.创建目的地//6.创建消费者//7.获取消息//8.关闭 @Test public void testConsumer() throws JMSException &#123; ConnectionFactory connectionFactory = new ActiveMQConnectionFactory(brokerURL); Connection connection = connectionFactory.createConnection(); connection.start(); Session session = connection.createSession(true, Session.AUTO_ACKNOWLEDGE); Destination destination = new ActiveMQQueue("javaQueue"); MessageConsumer consumer = session.createConsumer(destination); TextMessage receive =(TextMessage) consumer.receive(); String text = receive.getText(); System.out.println(text); session.commit(); //不commit就没有回执 consumer.close(); connection.close(); &#125; 注意:当生产者生产消息之后,不管何时,只要消费者启动,就会接收到消息(非时间依赖性) 2.发布者与订阅者(publisher &amp; subscriber)1.发布者(publisher)1234567891011121314151617@Test public void testPUB() throws JMSException &#123; //1.连接工厂 TopicConnectionFactory connectionFactory = new ActiveMQConnectionFactory(brokeURl); //2.创建连接 TopicConnection topicConnection = connectionFactory.createTopicConnection(); TopicSession topicSession = topicConnection.createTopicSession(true, Session.AUTO_ACKNOWLEDGE); Topic topic = new ActiveMQTopic("javaTopic"); TopicPublisher publisher = topicSession.createPublisher(topic); TextMessage textMessage = topicSession.createTextMessage(); textMessage.setText("hello subscriber"); publisher.send(textMessage); topicSession.commit(); publisher.close(); topicSession.close(); topicConnection.close(); &#125; 2.订阅者(subscriber) 订阅者可以有多个1234567891011121314151617181920 @Test public void testSUB() throws JMSException &#123; TopicConnectionFactory connectionFactory = new ActiveMQConnectionFactory(brokeURl);// 2.创建连接 TopicConnection topicConnection = connectionFactory.createTopicConnection(); topicConnection.start(); TopicSession topicSession = topicConnection.createTopicSession(true, Session.AUTO_ACKNOWLEDGE); Topic topic = new ActiveMQTopic("javaTopic"); TopicSubscriber subscriber = topicSession.createSubscriber(topic); //死循环保持订阅者活性 while (true) &#123; Message message = subscriber.receive(); TextMessage textMessage = (TextMessage) message; if (textMessage != null) &#123; System.out.println("订阅者1------"+textMessage.getText()); topicSession.commit(); &#125; else &#123; break; &#125; &#125; 注意:订阅者要在发布者之前启动,才会接收到发布者发布的消息(时间依赖性) 3.spring集成ActiveMQ1.相关依赖如果使用原生的ActiveMQ API开发会比较麻烦，因为需要创建连接工厂，创建连接等，我们应该使用一个模板来做这些繁琐的事情，Spring帮我们做了！ Spring提供了对JMS的支持，需要添加Spring支持jms的包, jmsTemplate是对基础API操作的封装。 123456789101112131415&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-jms&lt;/artifactId&gt; &lt;version&gt;4.0.0.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.activemq&lt;/groupId&gt; &lt;artifactId&gt;activemq-pool&lt;/artifactId&gt; &lt;version&gt;5.7.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.activemq&lt;/groupId&gt; &lt;artifactId&gt;activemq-core&lt;/artifactId&gt; &lt;version&gt;5.7.0&lt;/version&gt; &lt;/dependency&gt; 2.相关配置2.1 不使用连接池12345678910111213141516171819202122232425262728293031&lt;!--开启注解扫描:除Controller外的包--&gt; &lt;context:component-scan base-package="com.nyist" use-default-filters="true"&gt; &lt;context:exclude-filter type="annotation" expression="org.springframework.stereotype.Controller"&gt;&lt;/context:exclude-filter&gt; &lt;/context:component-scan&gt; &lt;!--和activemq集成--&gt; &lt;!--连接工厂--&gt; &lt;bean id="activeMQcf" class="org.apache.activemq.ActiveMQConnectionFactory"&gt; &lt;property name="password" value="admin"&gt;&lt;/property&gt; &lt;property name="userName" value="admin"&gt;&lt;/property&gt; &lt;property name="brokerURL" value="tcp://192.168.106.135:61616"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!--destination--&gt; &lt;!--点对点形式--&gt; &lt;bean id="queue" class="org.apache.activemq.command.ActiveMQQueue"&gt; &lt;property name="physicalName" value="springQueue"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!--发布订阅形式--&gt; &lt;bean id="topic" class="org.apache.activemq.command.ActiveMQTopic"&gt; &lt;property name="physicalName" value="springTopic"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!--会话使用jmsTemplate--&gt; &lt;bean id="jmsTemplate" class="org.springframework.jms.core.JmsTemplate"&gt; &lt;property name="connectionFactory" ref="activeMQcf"&gt;&lt;/property&gt; &lt;!--点对点ref="queue" 发布订阅ref="topic"--&gt; &lt;property name="defaultDestination" ref="topic"&gt;&lt;/property&gt; &lt;!--使用发布订阅该值为true，使用队列该值为false--&gt; &lt;property name="pubSubDomain" value="true"&gt;&lt;/property&gt; &lt;/bean&gt; 注意：admin账户与密码可以在activeMQ配置文件中修改为其他，admin时也可以不写出来。 生产者12345678910111213141516171819@Servicepublic class ProductServiceImpl implements ProductService &#123; @Autowired JmsTemplate jmsTemplate; @Override public void send(String msg) &#123; //Destination已在配置文件中声明固定 jmsTemplate.send(new MessageCreator() &#123; @Override public Message createMessage(Session session) throws JMSException &#123; TextMessage textMessage = session.createTextMessage(); textMessage.setText(msg); return textMessage; &#125; &#125;); &#125;&#125; 消费者12345678910111213141516171819@Servicepublic class ConsumerServiceImpl implements ConsumerService &#123; @Autowired JmsTemplate jmsTemplate; @Override public String recieve() &#123; TextMessage receive = (TextMessage) jmsTemplate.receive(); String text = null; try &#123; text = receive.getText(); System.out.println(text); &#125; catch (JMSException e) &#123; e.printStackTrace(); &#125; return text; &#125;&#125; Controller123456789101112131415161718192021@RestController@RequestMapping("/test")public class TestController &#123; @Autowired ProductService productService; @Autowired ConsumerService consumerService; @RequestMapping("/send") public void send(String msg) &#123; productService.send(msg); &#125; @RequestMapping("/recieve") public String recieve() &#123; String recieve = consumerService.recieve(); return recieve; &#125;&#125; Controller中注入以上两个接口即可测试，手动发请求测试发送消息，消费消息 或者测试发布订阅。 对于以上手动请求测试消费消息一定是不行的，可以使用activeMQ的监听器达到自动监听的效果。1.声明消息监听器123456789101112public class ConsumerListener implements MessageListener &#123; public void onMessage(Message message) &#123; TextMessage textMessage = (TextMessage) message; try &#123; String text = textMessage.getText(); System.out.println(text); &#125; catch (JMSException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 2.将相关对象交由工厂管理监听器实质上监听队列或者主体的变化 12345678910111213&lt;!--消息监听器--&gt; &lt;bean id="consumerListener" class="com.nyist.service.ConsumerListener"&gt;&lt;/bean&gt; &lt;!--消息监听容器--&gt; &lt;bean id="container" class="org.springframework.jms.listener.DefaultMessageListenerContainer"&gt; &lt;property name="connectionFactory" ref="activeMQcf"&gt;&lt;/property&gt; &lt;!--如果是发布订阅形式 此处必须为true，点对点则为false--&gt; &lt;property name="pubSubDomain" value="false"&gt;&lt;/property&gt; &lt;!--监听点对点--&gt; &lt;property name="destination" ref="queue"&gt;&lt;/property&gt; &lt;!-- 监听发布订阅 --&gt; &lt;!-- &lt;property name="destination" ref="topic"&gt;&lt;/property&gt; --&gt; &lt;property name="messageListener" ref="consumerListener"&gt;&lt;/property&gt; &lt;/bean&gt; 注意：监听容器指定一个监听器，监听方式要么点对点要么发布订阅 ，不可以同时监听两者。 使用连接池修改spring中连接配置为以下 12345678910111213141516171819&lt;bean id="jmsFactory" class="org.apache.activemq.pool.PooledConnectionFactory" destroy-method="stop"&gt; &lt;property name="connectionFactory"&gt; &lt;bean class="org.apache.activemq.ActiveMQConnectionFactory"&gt; &lt;property name="brokerURL"&gt; &lt;value&gt;tcp://192.168.106.135:61616&lt;/value&gt; &lt;/property&gt; &lt;/bean&gt; &lt;/property&gt; &lt;!--配置最大连接数--&gt; &lt;property name="maxConnections" value="100"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!--使用缓存可以提升效率--&gt; &lt;bean id="cachingConnectionFactory" class="org.springframework.jms.connection.CachingConnectionFactory"&gt; &lt;property name="targetConnectionFactory" ref="jmsFactory"/&gt; &lt;property name="sessionCacheSize" value="1"/&gt; &lt;/bean&gt; 3.springboot集成ActiveMQ1.相关依赖12345678&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-activemq&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.activemq&lt;/groupId&gt; &lt;artifactId&gt;activemq-pool&lt;/artifactId&gt; &lt;/dependency&gt; 2.配置1234567server.port=8989server.context-path=/amqspring.activemq.broker-url=tcp://192.168.106.135:61616spring.application.user=adminspring.activemq.password=adminspring.activemq.pool.enabled=truespring.activemq.pool.max-connections=10 3.生产者12345678910111213141516171819@RestController@RequestMapping("/test")public class ProductController &#123; @Autowired JmsTemplate jmsTemplate; @RequestMapping("/send") public void send(String msg)&#123; Destination destination = new ActiveMQQueue("springboot-queue"); jmsTemplate.convertAndSend(destination,msg); &#125; @RequestMapping("/pub") public void publisher(String msg)&#123; ActiveMQTopic topic = new ActiveMQTopic("springboot-topic"); jmsTemplate.convertAndSend(topic,msg); &#125;&#125; 4.消费者1234567891011121314151617181920@Componentpublic class Consumer &#123; @JmsListener(destination = "springboot-queue") public void receiveQueue(TextMessage msg) &#123; try &#123; System.out.println(msg.getText()); &#125; catch (JMSException e) &#123; e.printStackTrace(); &#125; &#125; @JmsListener(destination = "springboot-topic") public void receiveQueue(TextMessage msg) &#123; try &#123; System.out.println(msg.getText()); &#125; catch (JMSException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 关于springboot下的点对点与发布订阅，连接池使用，可以参考文章：http://www.cnblogs.com/elvinle/p/8457596.html在以上的spring或者springboot的测试中，消息体Message都是使用TextMessage形式，JMS规范中的消息类型包括TextMessage、MapMessage、ObjectMessage、BytesMessage、和StreamMessage等五种。 五种消息的生产123456789101112131415161718192021222324252627282930313233try &#123; //文本消息 if (messageType.getName().equals(MessageType.TEXT.getName())) &#123; TextMessage textMessage = session.createTextMessage("文本消息"); producer.send(textMessage); &#125; else if (messageType.getName().equals(MessageType.MAP.getName())) &#123; //键值对消息 MapMessage mapMessage = session.createMapMessage(); mapMessage.setLong("age", new Long(32)); mapMessage.setDouble("sarray1", new Double(5867.15)); mapMessage.setString("username", "键值对消息"); producer.send(mapMessage); &#125; else if (messageType.getName().equals(MessageType.STREAM.getName())) &#123; //流消息 StreamMessage streamMessage = session.createStreamMessage(); streamMessage.writeString("streamMessage流消息"); streamMessage.writeLong(55); producer.send(streamMessage); &#125; else if (messageType.getName().equals(MessageType.BYTE.getName())) &#123; //字节消息 String s = "BytesMessage字节消息"; BytesMessage bytesMessage = session.createBytesMessage(); bytesMessage.writeBytes(s.getBytes()); producer.send(bytesMessage); &#125; else &#123; User user = new User("cjm1", "对象消息", "1"); //User对象必须实现Serializable接口 ObjectMessage objectMessage = session.createObjectMessage(); objectMessage.setObject(user); producer.send(objectMessage); &#125; &#125; catch (JMSException e) &#123; e.printStackTrace(); &#125; 消费123456789101112131415161718192021222324252627282930try &#123; if (m instanceof TextMessage) &#123; //接收文本消息 TextMessage message = (TextMessage) m; System.out.println(message.getText()); &#125; else if (m instanceof MapMessage) &#123; //接收键值对消息 MapMessage message = (MapMessage) m; System.out.println(message.getLong("age")); System.out.println(message.getDouble("sarray1")); System.out.println(message.getString("username")); &#125; else if (m instanceof StreamMessage) &#123; //接收流消息 StreamMessage message = (StreamMessage) m; System.out.println(message.readString()); System.out.println(message.readLong()); &#125; else if (m instanceof BytesMessage) &#123; //接收字节消息 byte[] b = new byte[1024]; int len = -1; BytesMessage message = (BytesMessage) m; while ((len = message.readBytes(b)) != -1) &#123; System.out.println(new String(b, 0, len)); &#125; &#125; else if (m instanceof ObjectMessage) &#123; //接收对象消息1 ObjectMessage message = (ObjectMessage) m; User user = (User) message.getObject(); System.out.println(user.getName() + " _ " + user.getPassword()); &#125; else &#123; System.out.println(m); &#125; &#125; catch (JMSException e) &#123; e.printStackTrace(); &#125;]]></content>
      <categories>
        <category>消息中间件</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[MQ详解及中间件产品比较]]></title>
    <url>%2F2019%2F01%2F17%2FMQ%E8%AF%A6%E8%A7%A3%E5%8F%8A%E4%B8%AD%E9%97%B4%E4%BB%B6%E4%BA%A7%E5%93%81%E6%AF%94%E8%BE%83%2F</url>
    <content type="text"><![CDATA[Java Message Service 消息中间件的组成 消息机制-点对点与发布订阅 消息中间件的应用场景 MQ详解及中间件产品比较1.jms的概念1它是一种与厂商无关的API，用来访问消息收发系统消息。它类似于JDBC，JDBC是可以用来访问不同关系数据库的API，而JMS则提供同样与厂商无关的访问消息收发服务的方法,这样就可以通过消息收发服务实现从一个JMS客户机向另一个JMS客户机发送消息，所需要的是厂商支持JMS。换句话说，JMS是Java平台上有关面向消息中间件的技术规范，不同的的中间件产品是对jms接口的不同实现。 2.jms中关键的对象 ConnectionFactory 连接工厂 Connection 连接对象 Session，是发送和接收消息的上下文，用于创建消息生产者，消息消费者，相比rocketMQ会话session是提供事务性的； destination，指定生产消息的目的地和消费消息的来源对象；生产者、消费者，由会话创建的对象，顾名思义，分为队列和订阅两种。 3.消息中间件的组成 Broken ： 消息服务器，作为server提供消息核心服务 Producer：消息生产者，业务发起方，负责生产消息传输给broker Consumer：消息消费者，业务的处理方，负责从broken获取消息并进行业务逻辑处理 Topic： 主体，发布订阅模式下的统一汇集地，与Queue不同是两种方式。 Queue：队列，PTP(点对点模式)，特定生产者向queue发送消息。 Message：消息体，根据不同通信协议的固定格式进行编码的数据包，封装业务数据，以消息形式传送 4.消息机制-点对点与发布订阅1.p2p(点对点) 一个消息只用一个消费者(消息消费即删除) 发送者和消费者时间上没有依赖性 接收消息之后需向队列发送回执信息 目的地必须是队列 应用场景:订单和商品,应用解耦 2.pub and sub(发布订阅) 一个消息有多个消费者 时间上有依赖性(后来的消费者无法消费订阅到以前的消息) 应用场景:app的消息推送 5.消息中间件的优势1）系统解耦交互系统之间没有直接的调用关系，只是通过消息传输，故系统侵入性不强，耦合度低。 2）提高系统响应时间例如原来的一套逻辑，完成支付可能涉及先修改订单状态、计算会员积分、通知物流配送几个逻辑才能完成；通过MQ架构设计，就可将紧急重要（需要立刻响应）的业务放到该调用方法中，响应要求不高的使用消息队列，放到MQ队列中，供消费者处理。 3）为大数据处理架构提供服务通过消息作为整合，大数据的背景下，消息队列还与实时处理架构整合，为数据处理提供性能支持。 6.消息中间件的应用场景1）异步通信有些业务不想也不需要立即处理消息。消息队列提供了异步处理机制，允许用户把一个消息放入队列，但并不立即处理它。想向队列中放入多少消息就放多少，然后在需要的时候再去处理它们。 2）解耦降低工程间的强依赖程度，针对异构系统进行适配。在项目启动之初来预测将来项目会碰到什么需求，是极其困难的。通过消息系统在处理过程中间插入了一个隐含的、基于数据的接口层，两边的处理过程都要实现这一接口，当应用发生变化时，可以独立的扩展或修改两边的处理过程，只要确保它们遵守同样的接口约束。 3）冗余有些情况下，处理数据的过程会失败。除非数据被持久化，否则将造成丢失。消息队列把数据进行持久化直到它们已经被完全处理，通过这一方式规避了数据丢失风险。许多消息队列所采用的”插入-获取-删除”范式中，在把一个消息从队列中删除之前，需要你的处理系统明确的指出该消息已经被处理完毕，从而确保你的数据被安全的保存直到你使用完毕。 4）扩展性因为消息队列解耦了你的处理过程，所以增大消息入队和处理的频率是很容易的，只要另外增加处理过程即可。不需要改变代码、不需要调节参数。便于分布式扩容。 5）过载保护在访问量剧增的情况下，应用仍然需要继续发挥作用，但是这样的突发流量无法提取预知；如果以为了能处理这类瞬间峰值访问为标准来投入资源随时待命无疑是巨大的浪费。使用消息队列能够使关键组件顶住突发的访问压力，而不会因为突发的超负荷的请求而完全崩溃。 6）可恢复性系统的一部分组件失效时，不会影响到整个系统。消息队列降低了进程间的耦合度，所以即使一个处理消息的进程挂掉，加入队列中的消息仍然可以在系统恢复后被处理。 7）顺序保证在大多使用场景下，数据处理的顺序都很重要（如秒杀商品）。大部分消息队列本来就是排序的，并且能保证数据会按照特定的顺序来处理。 8）缓冲在任何重要的系统中，都会有需要不同的处理时间的元素。消息队列通过一个缓冲层来帮助任务最高效率的执行，该缓冲有助于控制和优化数据流经过系统的速度。以调节系统响应时间。 9）数据流处理分布式系统产生的海量数据流，如：业务日志、监控数据、用户行为等，针对这些数据流进行实时或批量采集汇总，然后进行大数据分析是当前互联网的必备技术，通过消息队列完成此类数据收集是最好的选择。 7.消息中间件常用协议 1 AMQP协议 AMQP即Advanced Message Queuing Protocol,一个提供统一消息服务的应用层标准高级消息队列协议,是应用层协议的一个开放标准,为面向消息的中间件设计。基于此协议的客户端与消息中间件可传递消息，并不受客户端/中间件不同产品，不同开发语言等条件的限制。优点：可靠、通用 2 MQTT协议 MQTT（Message Queuing Telemetry Transport，消息队列遥测传输）是IBM开发的一个即时通讯协议，有可能成为物联网的重要组成部分。该协议支持所有平台，几乎可以把所有联网物品和外部连接起来，被用来当做传感器和致动器（比如通过Twitter让房屋联网）的通信协议。优点：格式简洁、占用带宽小、移动端通信、PUSH、嵌入式系统 3 STOMP协议 STOMP（Streaming Text Orientated Message Protocol）是流文本定向消息协议，是一种为MOM(Message Oriented Middleware，面向消息的中间件)设计的简单文本协议。STOMP提供一个可互操作的连接格式，允许客户端与任意STOMP消息代理（Broker）进行交互。优点：命令模式（非topic\queue模式） 4 XMPP协议 XMPP（可扩展消息处理现场协议，Extensible Messaging and Presence Protocol）是基于可扩展标记语言（XML）的协议，多用于即时消息（IM）以及在线现场探测。适用于服务器之间的准即时操作。核心是基于XML流传输，这个协议可能最终允许因特网用户向因特网上的其他任何人发送即时消息，即使其操作系统和浏览器不同。优点：通用公开、兼容性强、可扩展、安全性高，但XML编码格式占用带宽大 5 其他基于TCP/IP自定义的协议 有些特殊框架（如：redis、kafka、zeroMq等）根据自身需要未严格遵循MQ规范，而是基于TCP\IP自行封装了一套协议，通过网络socket接口进行传输，实现了MQ的功能。 8.常见消息中间件1）RocketMQ阿里系下开源的一款分布式、队列模型的消息中间件，原名Metaq，3.0版本名称改为RocketMQ，是阿里参照kafka设计思想使用java实现的一套mq。同时将阿里系内部多款mq产品（Notify、metaq）进行整合，只维护核心功能，去除了所有其他运行时依赖，保证核心功能最简化，在此基础上配合阿里上述其他开源产品实现不同场景下mq的架构，目前主要多用于订单交易系统。该项目现已捐赠给Apache。 具有以下特点： 能够保证严格的消息顺序 提供针对消息的过滤功能 提供丰富的消息拉取模式 高效的订阅者水平扩展能力 实时的消息订阅机制 亿级消息堆积能力 与kafka的对比：https://rocketmq.apache.org/docs/motivation/ 2）RabbitMQ兔子消息队列，暗示自己跑的快-_- 使用Erlang编写的一个开源的消息队列，本身支持很多的协议：AMQP，XMPP, SMTP,STOMP，也正是如此，使的它变的非常重量级，更适合于企业级的开发。同时实现了Broker架构，核心思想是生产者不会将消息直接发送给队列，消息在发送给客户端时先在中心队列排队。对路由(Routing)，负载均衡(Load balance)、数据持久化都有很好的支持。多用于进行企业级的ESB整合。 3）ActiveMQApache下的一个子项目。使用Java完全支持JMS1.1和J2EE 1.4规范的 JMS Provider实现，少量代码就可以高效地实现高级应用场景。可插拔的传输协议支持，比如：in-VM, TCP, SSL, NIO, UDP, multicast, JGroups and JXTA transports。RabbitMQ、ZeroMQ、ActiveMQ均支持常用的多种语言客户端 C++、Java、.Net,、Python、 Php、 Ruby等。 4）Redis使用C语言开发的一个Key-Value的NoSQL数据库，开发维护很活跃，虽然它是一个Key-Value数据库存储系统，但它本身支持MQ功能，所以完全可以当做一个轻量级的队列服务来使用。对于RabbitMQ和Redis的入队和出队操作，各执行100万次，每10万次记录一次执行时间。测试数据分为128Bytes、512Bytes、1K和10K四个不同大小的数据。实验表明：入队时，当数据比较小时Redis的性能要高于RabbitMQ，而如果数据大小超过了10K，Redis则慢的无法忍受；出队时，无论数据大小，Redis都表现出非常好的性能，而RabbitMQ的出队性能则远低于Redis。 5）KafkaApache下的一个子项目，使用scala实现的一个高性能分布式Publish/Subscribe消息队列系统，具有以下特性： 快速持久化：通过磁盘顺序读写与零拷贝机制，可以在O(1)的系统开销下进行消息持久化； 高吞吐：在一台普通的服务器上既可以达到10W/s的吞吐速率； 高堆积：支持topic下消费者较长时间离线，消息堆积量大； 完全的分布式系统：Broker、Producer、Consumer都原生自动支持分布式，依赖zookeeper自动实现复杂均衡； 支持Hadoop数据并行加载：对于像Hadoop的一样的日志数据和离线分析系统，但又要求实时处理的限制，这是一个可行的解决方案。 6）ZeroMQ号称最快的消息队列系统，专门为高吞吐量/低延迟的场景开发，在金融界的应用中经常使用，偏重于实时数据通信场景。ZMQ能够实现RabbitMQ不擅长的高级/复杂的队列，但是开发人员需要自己组合多种技术框架，开发成本高。因此ZeroMQ具有一个独特的非中间件的模式，更像一个socket library，你不需要安装和运行一个消息服务器或中间件，因为你的应用程序本身就是使用ZeroMQ API完成逻辑服务的角色。但是ZeroMQ仅提供非持久性的队列，如果down机，数据将会丢失。如：Twitter的Storm中使用ZeroMQ作为数据流的传输。 ZeroMQ套接字是与传输层无关的：ZeroMQ套接字对所有传输层协议定义了统一的API接口。默认支持 进程内(inproc) ，进程间(IPC) ，多播，TCP协议，在不同的协议之间切换只要简单的改变连接字符串的前缀。可以在任何时候以最小的代价从进程间的本地通信切换到分布式下的TCP通信。ZeroMQ在背后处理连接建立，断开和重连逻辑。 特性： 无锁的队列模型：对于跨线程间的交互（用户端和session）之间的数据交换通道pipe，采用无锁的队列算法CAS；在pipe的两端注册有异步事件，在读或者写消息到pipe的时，会自动触发读写事件。 批量处理的算法：对于批量的消息，进行了适应性的优化，可以批量的接收和发送消息。 多核下的线程绑定，无须CPU切换：区别于传统的多线程并发模式，信号量或者临界区，zeroMQ充分利用多核的优势，每个核绑定运行一个工作者线程，避免多线程之间的CPU切换开销。 比较 9.MQ使用场景1）异步处理场景说明：用户注册后，需要发注册邮件和注册短信。传统的做法有两种 1.串行的方式；2.并行方式 a、串行方式：将注册信息写入数据库成功后，发送注册邮件，再发送注册短信。以上三个任务全部完成后，返回给客户端。 b、并行方式：将注册信息写入数据库成功后，发送注册邮件的同时，发送注册短信。以上三个任务完成后，返回给客户端。与串行的差别是，并行的方式可以提高处理的时间. 假设三个业务节点每个使用50毫秒钟，不考虑网络等其他开销，则串行方式的时间是150毫秒，并行的时间可能是100毫秒。因为CPU在单位时间内处理的请求数是一定的，假设CPU1秒内吞吐量是100次。则串行方式1秒内CPU可处理的请求量是7次（1000/150）。并行方式处理的请求量是10次（1000/100）小结：如以上案例描述，传统的方式系统的性能（并发量，吞吐量，响应时间）会有瓶颈。如何解决这个问题呢？ 引入消息队列，将不是必须的业务逻辑，异步处理。改造后的架构如下： 按照以上约定，用户的响应时间相当于是注册信息写入数据库的时间，也就是50毫秒。注册邮件，发送短信写入消息队列后，直接返回，因此写入消息队列的速度很快，基本可以忽略，因此用户的响应时间可能是50毫秒。因此架构改变后，系统的吞吐量提高到每秒20 QPS。比串行提高了3倍，比并行提高了两倍。 2）应用解耦场景说明：用户下单后，订单系统需要通知库存系统。传统的做法是，订单系统调用库存系统的接口。如下： 订单系统----------------&gt;库存系统（增减库存） 传统模式的缺点：假如库存系统无法访问，则订单减库存将失败，从而导致订单失败，订单系统与库存系统耦合，解决以上问题则需要引入消息队列，订单系统写入队列中，库存系统出现问题时，消息队列中的消息是没有被消费的，知道库存上线消费，保证了消息的可靠性。 3）流量削峰流量削锋也是消息队列中的常用场景，一般在秒杀或团抢活动中使用广泛。 应用场景：秒杀活动，一般会因为流量过大，导致流量暴增，应用挂掉。为解决这个问题，一般需要在应用前端加入消息队列。 a、可以控制活动的人数 b、可以缓解短时间内高流量压垮应用 用户的请求，服务器接收后，首先写入消息队列。假如消息队列长度超过最大数量(即商品数量)，则直接抛弃用户请求或跳转到错误页面。 秒杀业务根据消息队列中的请求信息，再做后续处理。 4）日志处理日志处理是指将消息队列用在日志处理中，比如Kafka的应用，解决大量日志传输的问题。架构简化如下 日志采集客户端，负责日志数据采集，定时写受写入Kafka队列 Kafka消息队列，负责日志数据的接收，存储和转发 日志处理应用：订阅并消费kafka队列中的日志数据 . 5）消息通讯消息通讯是指，消息队列一般都内置了高效的通信机制，因此也可以用在纯的消息通讯。比如实现点对点消息队列，或者聊天室等 点对点通讯： 客户端A和客户端B使用同一队列，进行消息通讯。 聊天室通讯： 10.消息中间件示例1）电商系统 消息队列采用高可用，可持久化的消息中间件。比如Active MQ，Rabbit MQ，Rocket Mq。 （1）应用将主干逻辑处理完成后，写入消息队列。消息发送是否成功可以开启消息的确认模式。（消息队列返回消息接收成功状态后，应用再返回，这样保障消息的完整性） （2）扩展流程（发短信，配送处理）订阅队列消息。采用推或拉的方式获取消息并处理。 （3）消息将应用解耦的同时，带来了数据一致性问题，可以采用最终一致性方式解决。比如主数据写入数据库，扩展应用根据消息队列，并结合数据库方式实现基于消息队列的后续处理。 2）日志收集系统 分为Zookeeper注册中心，日志收集客户端，Kafka集群和Storm集群（OtherApp）四部分组成。 Zookeeper注册中心，提出负载均衡和地址查找服务 日志收集客户端，用于采集应用系统的日志，并将数据推送到kafka队列 Kafka集群：接收，路由，存储，转发等消息处理 Storm集群：与OtherApp处于同一级别，采用拉的方式消费队列中的数据。]]></content>
      <categories>
        <category>消息中间件</category>
      </categories>
      <tags>
        <tag>消息中间件</tag>
        <tag>ActiveMQ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java8函数式数据处理-Stream]]></title>
    <url>%2F2019%2F01%2F16%2FJava8-Stream%2F</url>
    <content type="text"><![CDATA[函数式数据处理 函数式数据处理1. 流的概念集合:用来存储数据的容器 流(Stream): 用来处理数据的工具 优势: 简化编程 提高数据的处理效率 2. 流的运算过程由数据源放入流中开始，中间操作之后全部是流式处理结果，流处理结果经过终端操作后才能转化为结果数据： 数据源——–&gt;中间操作——–&gt;中间操作——–&gt;终端操作———&gt;结果数据中间操作: Stream&lt;T&gt; 方法 作用 返回值 filter(Predicate) 过滤 , 筛选 Stream sorted(Comparator) 排序 Stream distinct() 去重 Stream limit(long) 取前几个元素 Stream skip(int) 跳过前几个元素 Stream map(Function&lt;T,R&gt;) 将流中的每个元素利用函数映射为另一个元素 Stream flatMap(Function&lt;T,R&gt;) 将分散的流组合成一个整体的Stream Stream 中间操作示例：map映射：参数为Function接口，将流中的每个元素利用函数映射为另一个元素 1map(Student::getName) //学生转为了学生姓名流返回 flatMap：将多个T对象转为多个Stream，再做一个归集，将多个Stream归集为一个Stream 123456789101112131415161718192021222324252627public class TestFlatMap &#123; public static void main(String[] args) &#123; //去重，打印出字符串组成 List&lt;String&gt; list = Arrays.asList("ABC","XYZ","ZZC","MZC","DHG","BCZ","MDG"); Stream&lt;String&gt; res = list.stream().flatMap(new Function&lt;String, Stream&lt;String&gt;&gt;() &#123; @Override public Stream&lt;String&gt; apply(String s) &#123; String[] ss = s.split(""); Stream&lt;String&gt; result = Arrays.stream(ss); return result; &#125; &#125;); Stream&lt;String&gt; res2 = list.stream().flatMap(s-&gt;&#123; String[] ss = s.split(""); Stream&lt;String&gt; result = Arrays.stream(ss); return result; &#125;); //res2.distinct().collect(Collectors.toList()).forEach(System.out::println); Stream&lt;String[]&gt; stream1 = list.stream().map(s-&gt;s.split("")); Stream&lt;String&gt; res3 = stream1.flatMap(s-&gt;Arrays.stream(s)); //静态方法：(Arrays::stream) res3.distinct().collect(Collectors.toList()).forEach(System.out::println); &#125;&#125; 终端操作 Stream&lt;T&gt; 方法 作用 返回值 count() 返回元素的个数 long forEach(Consumer) 遍历Stream中的所有元素 void max(Comparator) / min(Comparator) 找最大/最小的元素 Optional findAny() 找到Stream中的某个对象 Optional findFirst() 找到Stream中的第一个对象 Optional allMatch(Predicate) 判断流中的元素是否都匹配条件 boolean anyMatch(Predicate) 判断流中得到元素是否有一个能匹配条件 boolean noneMatch(Predicate) 判断流中的元素是否都不能匹配条件 boolean collect(Collector&lt;T,A,R&gt;) 收集流中的元素 R R collect(Collector) Collector: 收集器 &lt;T,A,R&gt; 将Stream 转化收集最终成为 R对象 Collectors 工具类, 可以得到常用的各种Collector 3. Collectors中的常用静态方法:注意：Collectors收集器中静态方法的返回值： 123Map&lt;k, List&lt;T&gt;&gt;,Map&lt;K, Optional&lt;T&gt;&gt;Map&lt;K, T&gt; 12public static &lt;T&gt; Collector&lt;T,?,List&lt;T&gt;&gt; toList() 将流中的所有对象放入List 返回:List&lt;T&gt; 案例: List&lt;Student&gt; result = students.stream().collect( Collectors.toList() ); 123public static &lt;T&gt; Collector&lt;T,?,Double&gt; averagingInt(ToIntFunction&lt;? super T&gt; mapper) 将若干int数据计算平均值 返回值: Double 案例: double result = students.stream().collect(Collectors.averagingInt(Student::getScore)); 12public static &lt;T&gt; Collector&lt;T,?,Integer&gt; summingInt(ToIntFunction&lt;? super T&gt; mapper) 将若干int数组计算和 返回值 int 12public static &lt;T&gt; Collector&lt;T,?,Optional&lt;T&gt;&gt; maxBy(Comparator&lt;? super T&gt; comparator) 求所有对象的最大值 返回值 Optional&lt;T&gt; 12345678public static &lt;T&gt; Collector&lt;T,?,IntSummaryStatistics&gt; summarizingInt(ToIntFunction&lt;? super T&gt; mapper) 求若干int的数量, 最大值, 最小值 总和 , 平均值 案例: IntSummaryStatistics result = students.stream().collect(Collectors.summarizingInt(Student::getScore)); System.out.println(result.getCount()); System.out.println(result.getMax()); System.out.println(result.getMin()); System.out.println(result.getSum()); System.out.println(result.getAverage()); 12345public static Collector&lt;CharSequence,?,String&gt; joining(CharSequence delimiter) 将流中的所有对象拼成String , delemiter作为分隔符 案例: List&lt;String&gt; list= Arrays.asList("Liucy","Wangyx","Yangdd","Huxz"); String result = list.stream().collect(Collectors.joining(",")); System.out.println(result); 123public static &lt;T,K&gt; Collector&lt;T,?,Map&lt;K,List&lt;T&gt;&gt;&gt; groupingBy(Function&lt;T, K&gt; classifier) 将流中的对象,按Function中的结果K,做分组, 元素分别放入List中 返回值: Map&lt;K,List&lt;T&gt;&gt; 案例: Map&lt;String,List&lt;Student&gt;&gt; result = students.stream().collect(groupingBy(Student::getClassNumber)); 1234567public static &lt;T,K,A,D&gt; Collector&lt;T,?,Map&lt;K,D&gt;&gt; groupingBy(Function&lt;T,K&gt; classifier, Collector&lt;T,A,D&gt; downstream) 将流中的对象,按Function中的结果K,做分组, 再把分组的元素利用downstream 收集为D对象,作为Map的值 返回值: Map&lt;K,D&gt; 案例: Map&lt;String,Double&gt; result = students.stream().collect( groupingBy(Student::getClassNumber,averagingInt(Student::getScore) )); result.forEach((s,d)-&gt;System.out.println(s+":"+d)); 123public static &lt;T,A,R,RR&gt; Collector&lt;T,A,RR&gt; collectingAndThen(Collector&lt;T,A,R&gt; downstream, Function&lt;R,RR&gt; finisher) 先利用downstream做数据收集, 结果R, 然后将收集的R数据利用finisher函数转换为RR对象 案例: Student s = students.stream().collect(collectingAndThen(maxBy(comparing(Student::getScore)),Optional::get)); 1234public static &lt;T,U,A,R&gt; Collector&lt;T,?,R&gt; mapping(Function&lt;T, U&gt; mapper, Collector&lt;U,A,R&gt; downstream) 先利用函数 将流中的T对象,转换为U对象, 再利用downstream,将U对象收集为R对象 案例: String result = students.stream().collect(mapping(Student::getName, joining(","))); 123public static &lt;T,D,A&gt; Collector&lt;T,?,Map&lt;Boolean,D&gt;&gt; partitioningBy(Predicate&lt;T&gt; predicate, Collector&lt;T,A,D&gt; downstream) 先利用谓词,将流中的对象按true,false分为两组, 再将每组的对象利用downstream收集为D对象,放入map 案例: Map&lt;Boolean,Double&gt; result = students.stream().collect(partitioningBy(Student::isMale,averagingInt(Student::getScore))); 4.数值流基本类型的特化 IntStream DoubleStream LongStream Stream -&gt; IntStream mapToInt(ToIntFunction) T–&gt;int IntStream -&gt; Stream boxed() 数值范围 range(1,100) 左开右闭 rangeClosed(1,100) 左闭又闭 在一些中间操作中，涉及Int转为Integer或Integer转为Int，中间操作就包含了大量的封箱与拆箱，使得效率低下，因此引入了数值流，使流可以存放基本数据类型： 1）Stream —&gt; IntStream：来自Stream的mapToInt()方法 mapToInt(ToIntFunction) T—&gt;int 123456&gt;public static void main(String[] args)&#123;&gt; Stream&lt;Employee&gt; stream1 = list.stream();&gt; //Stream&lt;Integer&gt; stream2 = stream1.map(Employee::getAge);&gt; IntStream stream2 = stream1.mapToInt(Employee::getAge);&gt;&#125;&gt; 2）IntStream —&gt; Stream：来自IntStream的boxed()方法 123&gt;IntStream stream2 = stream1.mapToInt(Employee::getAge);&gt;Stream&lt;Integer&gt; resStream = stream2.boxed()&gt; 创建数值流 12&gt; IntStream in = IntStream.range(1, 100); //1-99 类似于Python&gt; 12&gt; IntStream in = IntStream.rangeClosed(1, 100); //1-100&gt; 使用IntStream流做一个质数判断： 12345678910111213141516&gt; public class ValueStream &#123;&gt; public static void main(String[] args) &#123;&gt; /*Predicate&lt;Integer&gt; prime = n-&gt;&#123;&gt; for (int i = 2; i &lt;= Math.sqrt(n); i++) &#123;&gt; if(n % i == 0) return false;&gt; &#125;&gt; return true;&gt; &#125;;*/&gt; &gt; Predicate&lt;Integer&gt; p2 = n -&gt;&#123;&gt; IntStream ist = IntStream.rangeClosed(2, (int)Math.sqrt(n));&gt; return ist.noneMatch(i-&gt;n % i == 0);//如果没有任何一个匹配取余为0，就为true返回&gt; &#125;;&gt; &#125;&gt; &#125;&gt;]]></content>
  </entry>
</search>
